---
title: "Performance in Computer Structure"
author: "eunwoo"
thumbnail: "/next.svg"
publishDate: "2024-10-08"
categoryId: 3
---

Performance metrics:
How do we conclude that System A	is  better (faster) than System B ?

# How to measure the performance of computer system
- Latency vs. Throughput
- CPU time / MIPS / Benchmark
- How to summarize the performance?

# Importance Of Performance Measurement
When designing the architecture of computer systems, we need to know which system (or design methodology) is better

***

## Throughput = (1/Latency) ?    -> No

If it takes T sec to do N tasks, throughput = N/T;  latency = T/N ?
If it takes t sec to do 1 task, latency = t;  throughput = 1/t ?

Latency , Throughput  -> 역수 관계! 하지만 그렇지 않은 경우도 있다. (not always)

![](https://velog.velcdn.com/images/eunwoo1341/post/441caedd-7257-49e3-9975-f0062a0272ca/image.png)

**Pipelining(파이프라이닝)** 은 여러 단계로 나누어진 작업을 동시에 실행할 수 있도록 만드는 구조이다. 
예를 들어, 하나의 명령어가 끝날 때까지 기다리지 않고, 다음 명령어를 동시에 실행하는 방식이다.
이 경우 Latency는 여전히 명령어 하나를 처리하는 데 걸리는 시간이므로 변하지 않는다. 그러나 파이프라인 덕분에 여러 명령어를 동시에 처리할 수 있기 때문에 Throughput은 크게 증가한다. (Overlapping을 해서 능률을 높임)

즉, Latency는 거의 변동이 없거나 일부 증가하더라도 Throughput이 증가할 수 있어, 역수 관계가 성립하지 않는다.

***

# Time – The First Type Of Performance

- 1. Wall-clock (잘 안씀), response time (latency), or elapsed time
ㄴ Actual time from start to completion: the time that user experience in real world
ㄴ Includes everything so unpredictable    
like ...
▫ CPU time for other programs as well as for itself
▫ Memory and disk access time
▫ Communication channel delay
▫ Operating system overhead …

- 2. <span className="text-red-600 font-bold">CPU (execution) time</span>
ㄴ CPU time spent for a given program (process)
ㄴ User CPU time (The CPU time spent in a program itself) + System CPU  time (The CPU time spent in the operating system performing a task on  behalf of the program)

즉, CPU 성능을 측정할때는 주로 **CPU time**을 사용한다.

***

# Measuring CPU Time: Clock

- All (or most) operations in computers are governed by a **clock** that runs at a constant rate.
ㄴ Clock signals are generated by a quartz crystal that is physical layout.
ㄴ Clock cycles, ticks, clock ticks, cycles …

- Operations in computer must be synchronized with internal clock.

- Length of clock period = clock cycle time
![](https://velog.velcdn.com/images/eunwoo1341/post/034a45c3-7cc3-4585-bc38-d2f0c1d46472/image.png)

- Clock rate = 1 / clock cycle time


***
- (TIP)
- 1. 1 피코초(ps)와 1 나노초(ns)의 관계:
1 ns = 10^3 ps = 1000 ps

- 2. K (kilo), M (mega), G (giga), T (tera), P (peta) 
... 각 각 10^3 씩 곱해짐 (또는 2^10 씩 곱해짐)

***

# Measuring CPU Time: Executing 1 Instruction

- Most instructions on most processors require multiple clock  cycles to complete.
ㄴ Some instructions may take only a few cycles, while others require dozens.

- How to calculate the time to execute 1 instruction?


<br/>

CPU execution time per 1 Instruction

= (# of clock cycles for instruction) X (Clock cycle time)

= (# of clock cycles for instruction) / Clock Rate

즉,

- **IC (Instruction count)**
ㄴ Number of instructions executed for a program
- **CPI (Clock Cycles Per Instruction)**
ㄴ Average clock cycles per instructions
ㄴ CPU clock cycles (# of clock cycles) = IC X CPI


### < Important! >

![](https://velog.velcdn.com/images/eunwoo1341/post/abdadeff-68a6-46c1-8ae5-473d78cccbe5/image.png)


ex: 예제문제

![](https://velog.velcdn.com/images/eunwoo1341/post/23487206-ce1a-4bb5-adf6-293bd2c111ba/image.png)

![](https://velog.velcdn.com/images/eunwoo1341/post/396f38df-f988-4db0-996a-2a65cc2ecc4f/image.png)

![](https://velog.velcdn.com/images/eunwoo1341/post/30c04737-fd12-49ab-8c56-e02147944723/image.png)

***

![](https://velog.velcdn.com/images/eunwoo1341/post/947e2d6d-27df-4733-9fe1-f275e0e31265/image.png)

CPU time = (IC x CPI) / Clock rate  이므로..
10 = IC x CPI / ( 400 MHz ) = IC x CPI / ( 400 x 10^6 Hz )

즉, IC x CPI = 400 x 10^7 Hz


다음으로, 6 = IC x ( CPI x 1.2 ) / Clock Rate

Clock Rate = IC x CPI x 0.2   , 이 식에 이전에 구한걸 대입하면
Clock Rate = 800 x 10^6 = 800 MHz

답은 800 MHz

***


![](https://velog.velcdn.com/images/eunwoo1341/post/272f6b7f-7546-464b-bfcb-248e3ed1c352/image.png)

CPU time(초단위) = IC x CPI / Clock Rate  이므로

-> Clock Rate / CPI  =  IC / CPU Time

<br/>

#### (1) 

P1:  3GHz / 1.5  = 3 x 10^9 / 1.5 = **2 x 10^9**      (2 billion instructions per second)

P2:  2.5GHz / 1.0 = 2.5 x 10^9 / 1.0 = **2.5 x 10^9**    (2.5 billion instructions per second)

P3:  4.0GHz / 2.2 = **4 x 10^9 / 2.2**  	(1.82 billion instructions per second)


#### (2) P1:

P1:
Number of cycles: 3 GHz x 10 seconds = 30 billion cycles
Number of instructions: 30 billion cycles / 1.5 CPI = 20 billion instructions
P2:
Number of cycles: 2.5 GHz x 10 seconds = 25 billion cycles
Number of instructions: 25 billion cycles / 1.0 CPI = 25 billion instructions
P3:
Number of cycles: 4.0 GHz x 10 seconds = 40 billion cycles
Number of instructions: 40 billion cycles / 2.2 CPI = 18.18 billion instructions

 CPI는 "Cycles Per Instruction"의 약자로, 한 명령어를 실행하는 데 필요한 평균 클럭 사이클 수를 의미, 그래서 총 사이클에서 CPI를 나누면 instruction 의 총 개수가 나옴.

***

![](https://velog.velcdn.com/images/eunwoo1341/post/e9f688da-6263-453b-973b-f384574b05b4/image.png)

***

# Rate – The Second Types Of Performance

## MIPS (Million Instructions Per Seconds)
:1초당 몇 백만개의 명령어들을 처리했는가?

![](https://velog.velcdn.com/images/eunwoo1341/post/5b5747ae-91c5-4386-8f89-ad7c590aae81/image.png)


- Specifies performance (roughly) inversely to execution time
- Easy to understand; faster machines means bigger MIPS
- Problems; (-> See examples in following slides)
▫	It does not take into account the capabilities of the instructions
▫	It varies between programs on the same computer
▫	It can even vary inversely with performance!!

***

# Ratio – The Third Type Of Performance
![](https://velog.velcdn.com/images/eunwoo1341/post/bd631250-9937-4ac4-ae56-1909f2594921/image.png)

***

## Benchmarks!   - 실제 성능을 측정함!

- ratio 기반

- “Program” designed to access (or compare) across different  chip/system architecture for a particular type of application
	- **Mimic a particular type of “workload”** on a component or system
	- Domain specific
	- Updated every few year to reflect changes in usage and technology
	- Written in a high level language & Designed for easily measured timing
	- Desirable attributes;
      ▫	Relevant: meaningful within the target domain
      ▫	Acceptance: vendors and users embrace it
      ▫	Coverage: does not oversimplify important factors in the target domain
      ▫	Understandable and Scalable
      
- Two de facto industry standard benchmarks
  - SPEC: CPU performance
  - TPC: OLTP (On-Line Transaction Processing) performance
  - 3DMark, CrystalDiskMark, Cinebench, high-end game (Battleground), …

***

## MIPS 같은 rate기반은 Harmonic Mean 조화평균을 써서 계산해야함
![](https://velog.velcdn.com/images/eunwoo1341/post/470c452c-6d70-4762-ae39-1f254110895f/image.png)

## Benchmarks 는 ratio기반이므로 기하평균 Geometric mean 으로 계산해야함

![](https://velog.velcdn.com/images/eunwoo1341/post/cf07bc5f-47cd-40be-b6a0-261b830ba361/image.png)

***


# Amdahl's Law - 암달의 법칙

컴퓨터 시스템에서 성능 최적화를 할 때, 전체 성능 향상의 한계를 설명하는 법칙.
즉, **시스템의 일부를 아무리 개선해도 나머지 부분이 여전히 전체 성능의 병목이 될 수밖에 없다는 원리를 나타냄**.
이 법칙은 성능 향상에 기여할 수 있는 부분과 그렇지 않은 부분의 관계를 수학적으로 설명.

![](https://velog.velcdn.com/images/eunwoo1341/post/e8d480b0-9ee4-45b2-9591-d937e52d784b/image.png)

이 예시는 Amdahl's Law의 핵심 개념인 "시스템의 일부분만 개선할 때 전체 시스템의 성능 향상은 제한적이다"를 잘 보여주고 있다.

![](https://velog.velcdn.com/images/eunwoo1341/post/49f3c04c-f160-4b2f-a1b7-e89baeb2e90f/image.png)

![](https://velog.velcdn.com/images/eunwoo1341/post/02f54f44-b5f4-4175-824a-6414feecc398/image.png)

***


# Generalization Of Amdahl’s Law

- The performance enhancement possible with a given improvement is limited by the amount that the improved feature is used.


![](https://velog.velcdn.com/images/eunwoo1341/post/232023c1-12cd-471c-bf47-3c165e266bb4/image.png)

![](https://velog.velcdn.com/images/eunwoo1341/post/f6cbe9ad-2216-489d-9804-d958d6368006/image.png)

***
![](https://velog.velcdn.com/images/eunwoo1341/post/9edb27ac-deca-4925-b5e8-04cbf59afa6e/image.png)

### Amdahl의 법칙 공식

**SpeedUp(E) = 1 / ((1-F) + F/S)**

여기서:

E는 성능 향상(Enhancement)
F는 향상된 부분의 비율(Fraction)
S는 해당 부분의 속도 향상 factor

<br/><br/>

FPSQR 하드웨어 개선의 경우:
F = 0.20
S = 10
SpeedUp = 1 / ((1 - 0.20) + 0.20/10) = 1 / 0.82 ≈ 1.22

즉, 전체 시스템이 약 1.22배 빨라집니다.


모든 FP 명령어 개선의 경우:
F = 0.50
S = 1.6
SpeedUp = 1 / ((1 - 0.50) + 0.50/1.6) = 1 / 0.8125 ≈ 1.23

즉, 전체 시스템이 약 1.23배 빨라집니다


### 비교

첫 번째 대안: 1.22배 성능 향상
두 번째 대안: 1.23배 성능 향상

### 결론: 두 번째 대안인 모든 FP 명령어를 1.6배 빠르게 만드는 것이 조금 더 나은 성능 향상을 제공합니다. 

***

# 문제 10  (중요!)

![](https://velog.velcdn.com/images/eunwoo1341/post/8d5d4a40-5918-41f0-8bb3-cc6e21f08b4f/image.png)

1.	 먼저 CPI(Cycles Per Instruction)를 계산
: ALU: 1 cycle Load: 5 cycles Store: 3 cycles Branch: 2 cycles 평균 CPI = (50% * 1) + (20% * 5) + (10% * 3) + (20% * 2) = 0.5 + 1.0 + 0.3 + 0.4 = 2.2 cycles

2.	Load 명령어의 CPI가 5에서 2로 개선됨. 이는 Load 명령어에 대해 5/2 = 2.5배의 성능 향상을 의미.

3.	Amdahl의 법칙을 적용
: F (개선되는 부분의 비율) = 20% = 0.2 (Load 명령어의 비율) S (속도 향상 factor) = 5/2 = 2.5 SpeedUp = 1 / ((1-F) + F/S) = 1 / ((1-0.2) + 0.2/2.5) = 1 / (0.8 + 0.08) = 1 / 0.88 ≈ 1.136

4.	따라서, 전체 성능 향상은 약 1.136배, 또는 13.6%

### 결론
: Load 명령어의 CPI를 5에서 2로 개선함으로써, 전체 시스템의 성능은 약 13.6% 향상

***

# Gustafson’s Law


![](https://velog.velcdn.com/images/eunwoo1341/post/f21eb230-9e30-44df-af55-50adb4ab80b6/image.png)

Gustafson의 법칙의 핵심은 프로세서 수가 증가함에 따라 병렬화 가능한 작업의 크기도 증가할 수 있다는 것입니다. 
이는 Amdahl의 법칙과 달리, 병렬 시스템의 확장성에 대해 더 낙관적인 견해를 제시합니다.

## Amdahl's Law:

고정된 크기의 문제에 적용
병렬화 불가능한 부분이 성능 향상의 한계를 결정
프로세서 수 증가에 따른 성능 향상의 한계를 보여줌


## Gustafson's Law:

문제 크기가 프로세서 수에 따라 확장 가능함을 가정
더 많은 프로세서로 더 큰 문제를 더 빠르게 해결 가능
병렬 시스템의 확장성에 대해 더 낙관적인 관점 제시


두 법칙은 서로 상반되는 것이 아니라, 다른 상황과 가정에 기반한 보완적인 모델입니다. 
Amdahl's Law는 고정된 작업에서의 한계를, Gustafson's Law는 확장 가능한 작업에서의 가능성을 설명합니다.

