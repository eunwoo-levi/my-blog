---
title: "Performance in Computer Structure"
author: "eunwoo"
thumbnail: "/next.svg"
publishDate: "2024-10-08"
---

Performance metrics:
How do we conclude that System A	is  better (faster) than System B ?

# How to measure the performance of computer system
- Latency vs. Throughput
- CPU time / MIPS / Benchmark
- How to summarize the performance?

# Importance Of Performance Measurement
When designing the architecture of computer systems, we need to know which system (or design methodology) is better

***

## Throughput = (1/Latency) ?    -> No

If it takes T sec to do N tasks, throughput = N/T;  latency = T/N ?
If it takes t sec to do 1 task, latency = t;  throughput = 1/t ?

Latency , Throughput  -> 역수 관계! 하지만 그렇지 않은 경우도 있다. (not always)

![](https://velog.velcdn.com/images/eunwoo1341/post/441caedd-7257-49e3-9975-f0062a0272ca/image.png)

**Pipelining(파이프라이닝)** 은 여러 단계로 나누어진 작업을 동시에 실행할 수 있도록 만드는 구조이다. 
예를 들어, 하나의 명령어가 끝날 때까지 기다리지 않고, 다음 명령어를 동시에 실행하는 방식이다.
이 경우 Latency는 여전히 명령어 하나를 처리하는 데 걸리는 시간이므로 변하지 않는다. 그러나 파이프라인 덕분에 여러 명령어를 동시에 처리할 수 있기 때문에 Throughput은 크게 증가한다. (Overlapping을 해서 능률을 높임)

즉, Latency는 거의 변동이 없거나 일부 증가하더라도 Throughput이 증가할 수 있어, 역수 관계가 성립하지 않는다.

***

# Time – The First Type Of Performance

- 1. Wall-clock (잘 안씀), response time (latency), or elapsed time
ㄴ Actual time from start to completion: the time that user experience in real world
ㄴ Includes everything so unpredictable    
like ...
▫ CPU time for other programs as well as for itself
▫ Memory and disk access time
▫ Communication channel delay
▫ Operating system overhead …

- 2. <span className="text-red-600 font-bold">CPU (execution) time</span>
ㄴ CPU time spent for a given program (process)
ㄴ User CPU time (The CPU time spent in a program itself) + System CPU  time (The CPU time spent in the operating system performing a task on  behalf of the program)

즉, CPU 성능을 측정할때는 주로 **CPU time**을 사용한다.

***

# Measuring CPU Time: Clock

- All (or most) operations in computers are governed by a **clock** that runs at a constant rate.
ㄴ Clock signals are generated by a quartz crystal that is physical layout.
ㄴ Clock cycles, ticks, clock ticks, cycles …

- Operations in computer must be synchronized with internal clock.

- Length of clock period = clock cycle time
![](https://velog.velcdn.com/images/eunwoo1341/post/034a45c3-7cc3-4585-bc38-d2f0c1d46472/image.png)

- Clock rate = 1 / clock cycle time


***
- (TIP)
- 1. 1 피코초(ps)와 1 나노초(ns)의 관계:
1 ns = 10^3 ps = 1000 ps

- 2. K (kilo), M (mega), G (giga), T (tera), P (peta) 
... 각 각 10^3 씩 곱해짐 (또는 2^10 씩 곱해짐)

***

# Measuring CPU Time: Executing 1 Instruction

- Most instructions on most processors require multiple clock  cycles to complete.
ㄴ Some instructions may take only a few cycles, while others require dozens.

- How to calculate the time to execute 1 instruction?


<br/>

CPU execution time per 1 Instruction

= (# of clock cycles for instruction) X (Clock cycle time)

= (# of clock cycles for instruction) / Clock Rate

즉,

- **IC (Instruction count)**
ㄴ Number of instructions executed for a program
- **CPI (Clock Cycles Per Instruction)**
ㄴ Average clock cycles per instructions
ㄴ CPU clock cycles (# of clock cycles) = IC X CPI


### < Important! >

![](https://velog.velcdn.com/images/eunwoo1341/post/abdadeff-68a6-46c1-8ae5-473d78cccbe5/image.png)


ex: 예제문제

![](https://velog.velcdn.com/images/eunwoo1341/post/23487206-ce1a-4bb5-adf6-293bd2c111ba/image.png)

![](https://velog.velcdn.com/images/eunwoo1341/post/396f38df-f988-4db0-996a-2a65cc2ecc4f/image.png)

![](https://velog.velcdn.com/images/eunwoo1341/post/30c04737-fd12-49ab-8c56-e02147944723/image.png)

***

![](https://velog.velcdn.com/images/eunwoo1341/post/947e2d6d-27df-4733-9fe1-f275e0e31265/image.png)

CPU time = (IC x CPI) / Clock rate  이므로..
10 = IC x CPI / ( 400 MHz ) = IC x CPI / ( 400 x 10^6 Hz )

즉, IC x CPI = 400 x 10^7 Hz


다음으로, 6 = IC x ( CPI x 1.2 ) / Clock Rate

Clock Rate = IC x CPI x 0.2   , 이 식에 이전에 구한걸 대입하면
Clock Rate = 800 x 10^6 = 800 MHz

답은 800 MHz

***


![](https://velog.velcdn.com/images/eunwoo1341/post/272f6b7f-7546-464b-bfcb-248e3ed1c352/image.png)

CPU time(초단위) = IC x CPI / Clock Rate  이므로

-> Clock Rate / CPI  =  IC / CPU Time

<br/>

#### (1) 

P1:  3GHz / 1.5  = 3 x 10^9 / 1.5 = **2 x 10^9**      (2 billion instructions per second)

P2:  2.5GHz / 1.0 = 2.5 x 10^9 / 1.0 = **2.5 x 10^9**    (2.5 billion instructions per second)

P3:  4.0GHz / 2.2 = **4 x 10^9 / 2.2**  	(1.82 billion instructions per second)


#### (2) P1:

P1:
Number of cycles: 3 GHz x 10 seconds = 30 billion cycles
Number of instructions: 30 billion cycles / 1.5 CPI = 20 billion instructions
P2:
Number of cycles: 2.5 GHz x 10 seconds = 25 billion cycles
Number of instructions: 25 billion cycles / 1.0 CPI = 25 billion instructions
P3:
Number of cycles: 4.0 GHz x 10 seconds = 40 billion cycles
Number of instructions: 40 billion cycles / 2.2 CPI = 18.18 billion instructions

 CPI는 "Cycles Per Instruction"의 약자로, 한 명령어를 실행하는 데 필요한 평균 클럭 사이클 수를 의미, 그래서 총 사이클에서 CPI를 나누면 instruction 의 총 개수가 나옴.

***

![](https://velog.velcdn.com/images/eunwoo1341/post/e9f688da-6263-453b-973b-f384574b05b4/image.png)

***

# Rate – The Second Types Of Performance

## MIPS (Million Instructions Per Seconds)
:1초당 몇 백만개의 명령어들을 처리했는가?

![](https://velog.velcdn.com/images/eunwoo1341/post/5b5747ae-91c5-4386-8f89-ad7c590aae81/image.png)


- Specifies performance (roughly) inversely to execution time
- Easy to understand; faster machines means bigger MIPS
- Problems; (-> See examples in following slides)
▫	It does not take into account the capabilities of the instructions
▫	It varies between programs on the same computer
▫	It can even vary inversely with performance!!




export default function Layout({children}) {
  return <div className="prose">{children}</div>;
}
