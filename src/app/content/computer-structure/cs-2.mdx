---
title: "Performance questions in Computer Structure"
author: "eunwoo"
thumbnail: "/next.svg"
publishDate: "2024-10-11"
---



### < Important! >

![](https://velog.velcdn.com/images/eunwoo1341/post/abdadeff-68a6-46c1-8ae5-473d78cccbe5/image.png)

***

# 문제 1

![](https://velog.velcdn.com/images/eunwoo1341/post/23487206-ce1a-4bb5-adf6-293bd2c111ba/image.png)

# 문제 2

![](https://velog.velcdn.com/images/eunwoo1341/post/396f38df-f988-4db0-996a-2a65cc2ecc4f/image.png)

![](https://velog.velcdn.com/images/eunwoo1341/post/30c04737-fd12-49ab-8c56-e02147944723/image.png)

***

# 문제 3 (중요)

![](https://velog.velcdn.com/images/eunwoo1341/post/947e2d6d-27df-4733-9fe1-f275e0e31265/image.png)

CPU time = (IC x CPI) / Clock rate  이므로..
10 = IC x CPI / ( 400 MHz ) = IC x CPI / ( 400 x 10^6 Hz )

즉, IC x CPI = 400 x 10^7 Hz


다음으로, 6 = IC x ( CPI x 1.2 ) / Clock Rate

Clock Rate = IC x CPI x 0.2   , 이 식에 이전에 구한걸 대입하면
Clock Rate = 800 x 10^6 = 800 MHz

답은 800 MHz

***

# 문제 4

![](https://velog.velcdn.com/images/eunwoo1341/post/272f6b7f-7546-464b-bfcb-248e3ed1c352/image.png)

CPU time(초단위) = IC x CPI / Clock Rate  이므로

-> Clock Rate / CPI  =  IC / CPU Time

<br/>

#### (1) 

P1:  3GHz / 1.5  = 3 x 10^9 / 1.5 = **2 x 10^9**      (2 billion instructions per second)

P2:  2.5GHz / 1.0 = 2.5 x 10^9 / 1.0 = **2.5 x 10^9**    (2.5 billion instructions per second)

P3:  4.0GHz / 2.2 = **4 x 10^9 / 2.2**  	(1.82 billion instructions per second)


#### (2) P1:

P1:
Number of cycles: 3 GHz x 10 seconds = 30 billion cycles
Number of instructions: 30 billion cycles / 1.5 CPI = 20 billion instructions
P2:
Number of cycles: 2.5 GHz x 10 seconds = 25 billion cycles
Number of instructions: 25 billion cycles / 1.0 CPI = 25 billion instructions
P3:
Number of cycles: 4.0 GHz x 10 seconds = 40 billion cycles
Number of instructions: 40 billion cycles / 2.2 CPI = 18.18 billion instructions

 CPI는 "Cycles Per Instruction"의 약자로, 한 명령어를 실행하는 데 필요한 평균 클럭 사이클 수를 의미, 그래서 총 사이클에서 CPI를 나누면 instruction 의 총 개수가 나옴.

***

# 문제 5
![](https://velog.velcdn.com/images/eunwoo1341/post/e9f688da-6263-453b-973b-f384574b05b4/image.png)

***

# 문제 6  (중요)

## Calculating MIPS

![](https://velog.velcdn.com/images/eunwoo1341/post/c06b1c8b-9336-4df1-91d0-6547eefb7128/image.png)


![](https://velog.velcdn.com/images/eunwoo1341/post/5b937b87-f9d5-406c-a5e7-2f65afa83f6c/image.png)

MIPS 는 클수록 빠른거다!!

### MIPS  = IC / (Execution time × 10^6)

<br/><br/><br/>


- 평균 CPI(Cycles Per Instruction)를 계산
: Arithmetic and Logic: 1 x 0.60 = 0.60 
  Load & Store with cache hit: 2 x 0.18 = 0.36 
  Branch: 4 x 0.12 = 0.48 
  Memory reference with cache miss: 8 * 0.10 = 0.80 
  평균 CPI = 0.60 + 0.36 + 0.48 + 0.80 = 2.24


- 프로그램 실행 시간 계산
: CPU 시간 = IC x CPI / Clock Rate
= 2,000,000 x 2.24 / 400,000,000 = 0.0112 초

- MIPS 계산
: MIPS = 명령어 수 / (실행 시간 x 10^6) = 2,000,000 / (0.0112 x 10^6) = 178.57
따라서 이 프로세서의 성능은 약 **178.57 MIPS**

***

# 문제 7

![](https://velog.velcdn.com/images/eunwoo1341/post/8101acc1-91a9-47c5-8519-13e4e34a3f30/image.png)
![](https://velog.velcdn.com/images/eunwoo1341/post/6792c129-06e4-406f-967b-51b224caafc6/image.png)

***

# 문제 8

## 산술평균, 조화평균, 기하평균

![](https://velog.velcdn.com/images/eunwoo1341/post/d66c59a8-8874-4136-ab75-3ea86dbdee8b/image.png)


***


![](https://velog.velcdn.com/images/eunwoo1341/post/3dcf3e3b-ed2c-4dca-9d49-2bae356ebe90/image.png)


(1) 산술평균 (Arithmetic mean)
(36 + 40) / 2 = 38   (산술 평균)

(2) 조화평균 (Harmonic mean) - 시간기반 , rate 기반

2 / (1/72 + 1/90) = 2 * 72 * 90 =

2 x 72 x 90 / ( 72 + 90 ) = 2 x 72 x 90 / 162 = 80 km/h

(3) 기하평균 (Geometric mean) - 중요 - ratio 기반(Benchmark) (평균 몇배)

![](https://velog.velcdn.com/images/eunwoo1341/post/8a3f9809-1ebe-443f-814d-e08f7d6f40ad/image.png)

***

# 문제 9
## Amdahl's Law - 암달의 법칙

![](https://velog.velcdn.com/images/eunwoo1341/post/8db50b9a-0652-47fd-bef6-2b83cdbadbd9/image.png)
***
![](https://velog.velcdn.com/images/eunwoo1341/post/6c189205-e4e6-4507-84b4-f5457aec63f8/image.png)

### Amdahl의 법칙 공식

**SpeedUp(E) = 1 / ((1-F) + F/S)**

여기서:

E는 성능 향상(Enhancement)
F는 향상된 부분의 비율(Fraction)
S는 해당 부분의 속도 향상 factor

<br/><br/>

FPSQR 하드웨어 개선의 경우:
F = 0.20
S = 10
SpeedUp = 1 / ((1 - 0.20) + 0.20/10) = 1 / 0.82 ≈ 1.22

즉, 전체 시스템이 약 1.22배 빨라집니다.


모든 FP 명령어 개선의 경우:
F = 0.50
S = 1.6
SpeedUp = 1 / ((1 - 0.50) + 0.50/1.6) = 1 / 0.8125 ≈ 1.23

즉, 전체 시스템이 약 1.23배 빨라집니다


### 비교

첫 번째 대안: 1.22배 성능 향상
두 번째 대안: 1.23배 성능 향상

### 결론: 두 번째 대안인 모든 FP 명령어를 1.6배 빠르게 만드는 것이 조금 더 나은 성능 향상을 제공합니다. 

***

# 문제 10  (중요!)

![](https://velog.velcdn.com/images/eunwoo1341/post/8d5d4a40-5918-41f0-8bb3-cc6e21f08b4f/image.png)

1.	 먼저 CPI(Cycles Per Instruction)를 계산
: ALU: 1 cycle Load: 5 cycles Store: 3 cycles Branch: 2 cycles 평균 CPI = (50% * 1) + (20% * 5) + (10% * 3) + (20% * 2) = 0.5 + 1.0 + 0.3 + 0.4 = 2.2 cycles

2.	Load 명령어의 CPI가 5에서 2로 개선됨. 이는 Load 명령어에 대해 5/2 = 2.5배의 성능 향상을 의미.

3.	Amdahl의 법칙을 적용
: F (개선되는 부분의 비율) = 20% = 0.2 (Load 명령어의 비율) S (속도 향상 factor) = 5/2 = 2.5 SpeedUp = 1 / ((1-F) + F/S) = 1 / ((1-0.2) + 0.2/2.5) = 1 / (0.8 + 0.08) = 1 / 0.88 ≈ 1.136

4.	따라서, 전체 성능 향상은 약 1.136배, 또는 13.6%

#### 결론
: Load 명령어의 CPI를 5에서 2로 개선함으로써, 전체 시스템의 성능은 약 13.6% 향상




export default function Layout({children}) {
  return <div className="prose">{children}</div>;
}
