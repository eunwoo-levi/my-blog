---
title: "Computer System"
author: "eunwoo"
thumbnail: "/next.svg"
publishDate: "2024-10-10"

---


# Schematic Overview of Computer System


![](https://velog.velcdn.com/images/eunwoo1341/post/1cf12b76-08d2-41f9-89be-02c4801d4f63/image.png)

운영체제(Operating System)라는 interface를 통해서 컴퓨터의 복잡한 원리를 모르더라도 사용 가능
지금 현재 컴퓨터(CPU)는 모든 data와 cpu가 수행해야하는 명령어 등은 Memory를 통해서 수행 이후 I/O devices들이 Memory에서 읽어서 보여줌




***

# Von Neumann Machine

### Stored-program computer
(프로그램 명령어와 데이터를 같은 메모리에 저장)

- Processing unit can communicate with **main memory** only.
▫	**A processing unit** that contains an arithmetic logic unit and processor registers
▫	**A control unit** that contains an instruction register and program counter
▫	**Memory** that stores data and instructions
▫	External mass storage
▫	Input and output mechanisms

- Von Neumann bottleneck (폰노이만 병목 현상)
▫	Cache
▫	Modified Harvard architecture
▫	On-chip scratchpad memory
▫	Memory hierarchy
▫	DMA …

![](https://velog.velcdn.com/images/eunwoo1341/post/0009d030-ea2b-435b-9bc4-e0d87e8ce647/image.png)

### 작동 원리

- **메모리**에서 명령어를 가져와 해독하고 실행하는 순차적 처리
- **프로그램 카운터 (PC)**가 다음 실행할 명령어의 주소를 가리킴

***


# Instruction Set Architecture (ISA)

![](https://velog.velcdn.com/images/eunwoo1341/post/4500edf4-8923-4e64-9bd4-9f4da7e12f08/image.png)
- ISA는 컴퓨터 아키텍처의 중요한 개념으로, 하드웨어와 소프트웨어 사이의 인터페이스를 정의

"the attributes of a [computing] system as seen by the  programmer, i.e. the conceptual structure (**state**) and  functional behavior (**operations**), as distinct from the  organization of the data flow and controls, the logical design,  and the physical implementation"



- 중앙의 빨간 박스는 "Registers + Memory"를 나타냅니다. 이는 ISA의 'state' 부분을 표현
- 박스 주변의 "instruction"들은 시스템이 수행할 수 있는 연산들을 나타냅니다. 이는 ISA의 'operations' 부분을 표현

<br/><br/>

### Register와 State:

Register는 CPU 내부의 고속 저장 장치로, 현재 처리 중인 데이터와 프로그램의 즉각적인 실행 상태를 저장합니다. 
이는 state의 가장 즉각적이고 빠르게 변화하는 부분을 나타냅니다.

Register는 이름으로 접근

### Memory와 State:

Memory는 더 큰 용량의 저장소로, 실행 중인 프로그램의 전체 코드와 데이터를 포함합니다.
이는 프로그램의 전반적인 상태와 더 장기적인 state 정보를 저장합니다.

Memory는 주소로 접근

<br/>

**즉, register와 memory는 함께 ISA에서 정의하는 시스템의 전체 state를 구성하며, 프로그래머가 이해하고 조작할 수 있는 시스템의 현재 상태를 나타냅니다.**


### ISA의 중요성

ISA는 하드웨어와 소프트웨어 사이의 계약과 같은 역할을 합니다.
프로그래머는 ISA를 통해 하드웨어의 세부 구현을 알 필요 없이 시스템을 프로그래밍할 수 있습니다.
하드웨어 설계자는 ISA 규격을 준수하면서 다양한 방식으로 하드웨어를 최적화할 수 있습니다.

***
# ISA 예제

![](https://velog.velcdn.com/images/eunwoo1341/post/e6140b59-81cb-4d8b-99f0-b351736a6cd8/image.png)
PC를 통해 다음 명령어를 수행

lw(Load Word) -  MIPS 아키텍처: 메모리에서 32비트 워드를 레지스터로 로드하는 명령

lw r1, 1(r0) 에서 1은 r0 레지스터 값에 더할 Offset (바이트 단위)
즉, 1(r0) 은 1 + 1 = 2 
Memory의 주소 2에 해당되는 값을 r1 레지스터에 저장.

<br/>
이후에 PC 레지스터에 명령어에 의해서 메모리의 주소 22에 해당되는 명령어를 수행

![](https://velog.velcdn.com/images/eunwoo1341/post/647e5387-6630-418b-b91e-7d91a7f5e473/image.png)

### lw r2,2(r0) 명령어의 실행 과정

- 명령어 해석:

lw: Load Word (메모리에서 레지스터로 데이터 로드)
r2: 목적지 레지스터
2(r0): 메모리 주소 계산 (r0의 값 + 2)

<br/>
- 메모리 주소 계산:

r0의 값 = 1
Offset = 2
실제 메모리 주소 = 1 + 2 = 3

<br/>
- 데이터 로드:

메모리 주소 3의 값 = 7
이 값(7)을 r2 레지스터에 로드

<br/>
- 결과:

r2 레지스터의 새 값 = 7

<br/>

### 변경된 상태

r2 레지스터: 빈 상태에서 7로 변경
PC (Program Counter): 21에서 22로 증가 (다음 명령어 위치)

![](https://velog.velcdn.com/images/eunwoo1341/post/94aaf620-9180-4eee-95be-85aaf084367b/image.png)



![](https://velog.velcdn.com/images/eunwoo1341/post/88c186d9-9dbc-4773-80ce-e4246c918b5c/image.png)

**SW: Store Word**
목적: 레지스터의 내용을 메모리에 저장
즉 0 + 1 = 1 이므로 메모리 주소 1에 해당되는 곳에 r3 레지스터 값(9)을 저장. 


***

![](https://velog.velcdn.com/images/eunwoo1341/post/a770b35c-4082-4ac2-a9e9-4cf88feeff28/image.png)

# Computer System (1): Mode Bit


- Dual mode (or multi-mode) in OS by setting “mode bit”
	- Mode bit is a flag in hardware (stored in a register called Program  Status Word (PSW) register)
	- Indicates the current mode of execution
	▫ **Mode bit 0 -> The system is in kernel mode** (monitor mode, privileged  mode, supervisor mode, system mode) -> The **OS** gains control of the  processor (computer)
	▫ **Mode bit 1 -> The system is in user mode** -> The user application is  running
	- **Interrupt or system call -> changing mode bit from 1 to 0** -> mode transition from user mode to kernel mode (explained in later slides)

- Why dual mode (or multi-mode)?
	- Protect OS itself and other system components (ex. memory protection) from incorrect or illegal program execution
▫	A running user program can accidentally wipe out the operating system by  overwriting it with user data.
▫	Multiple processes can write in the same system at the same time, with  disastrous results

***

# Computer System (2): Timer

- The main task of a timer is to interrupt the CPU after a specific period  of time (-> It is determined by hardware design)
- Whenever the clock ticks, the counter is decremented
	▫	When the value of this counter reaches “zero”, an interrupt occurs and control is transferred back to the operating system (**timer interrupt**)
- Used to prevent a user program from monopolizing(독점) CPU  (ex. running too long)
- Used to implement time-sharing system
  (Example)
  . Program with 7 minutes time limit
  . Its counter initialized to 420
  . For every clock tick, the counter is decremented by 1

  -> After 420 ticks, the control is  automatically transferred back to  the operating system

![](https://velog.velcdn.com/images/eunwoo1341/post/15be6f67-dcf5-4993-adde-9ebb9ea456ca/image.png)


***

![](https://velog.velcdn.com/images/eunwoo1341/post/15be6f67-dcf5-4993-adde-9ebb9ea456ca/image.png)

### 모드 전환 순서

(1) Program 1 실행 (User 모드)
프로그램 1의 main() 함수 실행 중

(2) 타이머 인터럽트 발생 → Kernel 모드로 전환
인터럽트 처리를 위해 OS의 schedule() 함수로 제어 이동

(3) OS의 schedule() 함수 실행 (Kernel 모드)
다음 실행할 프로그램 결정

(4) Program 2로 전환 → User 모드로 전환
Program 2의 main() 함수 실행 시작

(5) Program 2 실행 중 타이머 인터럽트 발생 → Kernel 모드로 전환
다시 OS의 schedule() 함수로 제어 이동

(6) OS의 schedule() 함수 실행 (Kernel 모드)
다음 실행할 프로그램 결정

(7) Program 1로 재전환 → User 모드로 전환
Program 1의 main() 함수 실행 재개 (k+1 지점부터)

(8) 다시 타이머 인터럽트 발생 → Kernel 모드로 전환
OS의 schedule() 함수로 제어 이동

***


# Computer System (3): I/O Device

### I/O device controller
- **Hardware unit** which is attached to the input/output bus of the computer and provides a hardware **interface between the computer  and the I/O devices**

- **Another type of small CPU** -> control register, status register

- Local buffer (like memory)
After finishing I/O processing, the device controller sends an interrupt  signal to the CPU

- **Device driver**
▫	Computer program that operates or controls a particular type of device  that is attached to a computer
▫	**Another type of small operating system for I/O devices**
(Firmware/Middleware)
▫	**Software interface** to hardware devices, enabling operating systems and  other computer programs to access hardware functions without needing  to know precise details  provide abstraction by acting as a translator  between a hardware device and the applications or operating systems
▫	(ex) .sys in Window or .ko in Linux

***

<h1 className="text-red-600 font-bold">Computer System (4):  Exception (Interrupt)</h1>

- An **interrupt** (or exception) is a transfer of control to the OS  in response to some event	(i.e., change in processor state)

![](https://velog.velcdn.com/images/eunwoo1341/post/7d6dbfc5-8453-4f79-8756-e68746e0f41a/image.png)

### Exception 처리 과정
(1) Exception 발생 (주로 User 모드)

(2) 모드 전환: User 모드 → Kernel 모드
	- CPU가 자동으로 특권 수준 변경

(3) Kernel 모드에서 Exception 처리
- Exception 핸들러 실행
- 상황 분석 및 적절한 조치 결정

(4) 처리 완료 후 모드 전환: Kernel 모드 → User 모드
- 프로그램 재개 또는 종료

<br/>

## Asynchronous Exceptions : **Interrupt**

- Caused by events **external** to the processor (e.g., I/O devices)
  - Indicated by setting the processor’s interrupt pin (IRQ)
  - **Unpredictable**
  - Handler returns to “**next**” instruction

- Examples:
  - **Timer interrupt**
    ▫	Every few ms, an external timer triggers an interrupt
    ▫	Used by the kernel to take back control from user programs
  - **I/O interrupt from external device**
    ▫	Hitting Ctrl-C at the keyboard
    ▫	Arrival of a packet from a network
    ▫	Arrival of data to memory from I/O devices such as disk (HDD or SSD)

***

***

## Synchronous Exceptions

- Caused by events that occur as a result of executing an  instruction, and **triggered by the CPU itself**   
(“software interrupt”  or “internal interrupt”)

## Traps
▫	**Intentional**
▫	Examples: system calls, breakpoint traps, special instructions
▫	Returns control to “next” instruction

## Faults
▫	**Unintentional but possibly recoverable**
▫	Examples: page faults (recoverable), protection faults (unrecoverable), floating
point exceptions (divide by 0), invalid memory access …
▫	Either re-executes faulting (“current”) instruction or aborts

## Aborts
▫	**Unintentional and unrecoverable**
▫	Examples: illegal instruction, parity error, machine check
▫	Aborts current program

***
![](https://velog.velcdn.com/images/eunwoo1341/post/8655f5b6-201d-479d-b2d1-140c6f3c2d7b/image.png)


<br/><br/>




export default function Layout({children}) {
  return <div className="prose">{children}</div>;
}