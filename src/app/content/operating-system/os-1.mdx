---
title: "Operating System"
author: "eunwoo"
thumbnail: "/next.svg"
publishDate: "2024-10-05"

---


# Operating System?

<img src="https://velog.velcdn.com/images/eunwoo1341/post/72bf92d7-bf80-4c84-9956-4d4b5e49ce81/image.png" className="w-[800px] h-[500px]"/>

<u>Software layer between **users applications and computer hardware**</u>
ㄴ Interfacing with computer hardware and user applications software
ㄴ Very large (systemm) program or suite of programs executed by the processor


<img src="https://velog.velcdn.com/images/eunwoo1341/post/146a2681-1471-4da1-acdd-632c12968c46/image.png" className="w-[800px] h-[400px]"/>


***
# Interface?
<u>We can use functions even without knowing the  underlying complexity of device (or hardware)</u>
ㄴ Provides convenient functionality to higher levels
ㄴ Permits an efficient implementation at lower levels

***

# Two Perspectives in Operating System

## - 1. Resource management (or coordinator)

⊙ (Efficiency) An OS allows the complex computer system resources  (hardware, which is limited) to be used (managed) in an efficient manner  for maximizing the performance
⊙ (Fairness) Fairly allocate hardware resources
-> guarantee user experience

## - 2. Make the computer system convenient to use

⊙ (Convenience) Allow user (or application programs) to be executed easily  (without knowing the underlying complex hardware/software details)
⊙ Make solving user problems (or requests) easily by using a computer system

***

## How many users can be executed at the same time?

⊙ **A single user system** is a system in which only one user can access the  computer system at a time.
▫	Simple but limited performance
▫	MS-DOS, Windows, Mac OS, …

⊙ **A multi user system** is a system that allows more than one user to  access a computer system at a time.
▫	Complex
▫	Need to schedule different tasks
▫	Need to manage the protection or authority of each users
▫	Can improve an overall performance
▫	Unix, Mainframe, Windows NT, Linux …

⊙ A single tasking system can only run one program or application at a
time.
▫	MS-DOS, Windows cmd
⊙ A multi tasking system can run (or handle) multiple applications and  programs at once.
▫	Most modern OS such as Linux, Unix, Windows, …

***

⊙ Monolithic Kernel
-Single large process running entirely in a single address space.
-All kernel services exist and execute in the kernel address space.
-Each component can efficiently communicate: Faster
-Difficult to add/delete disk drivers & Difficult to maintain (why? Big)
-UNIX, Linux

⊙ Micro Kernel
-The kernel is broken down into separate processes, known as servers.
-All servers are kept separate and run in different address spaces.
-Servers invoke "services" from each other by sending messages via IPC  (Inter Process Communication)
-Mac OS X, Windows NT, MINIX

⊙ Hybrid Kernel


<img src="https://velog.velcdn.com/images/eunwoo1341/post/01f3709e-7ca9-48eb-858b-1df7998eee6a/image.png" className="w-[800px] h-[500px]"/>


<br/>

***

# History of Operating System

## (Single) Batch processing ~1960s : As computers became faster

⊙ <u> Grab all types of programs and data in the batch form then proceed to  process together</u>
▫	Collects similar jobs, executes them automatically **without manual intervention**
▫	Special programming language, JCL (Job Control Language) in monitor
▫	Decrease the setup and takedown time -> **improve CPU utilization**

⊙ Monitor -> Simple scheduler
⊙ Single batch possesses all resources of system -> Difficult to predict run  time for a job (e.g., if any job fails)
⊙ Beneficial to a large number of jobs
▫	Mainframe (Payroll or Bank systems …)

![](https://velog.velcdn.com/images/eunwoo1341/post/47934227-f85b-483a-86f7-274c88a6e09f/image.png)

배치 처리 시스템에서 작업(Job) 간에 I/O 작업이 발생하면, CPU는 I/O 작업이 완료될 때까지 대기해서 비효율적
-> I/O 작업이 실행될 때, 다른 작업을 동시에 처리하는 방식이 제안. 
-> 이는 Overlapping 을 통해 I/O와 CPU 작업이 동시에 진행되도록 하는 방식
-> CPU utilization 향상

***

# Multiprogramming batch processing	1960s ~ 1970s

⊙ Multiple users shared the system
▫	Degree of multiprogramming ≥ 1
▫ Multiple batch programs running at the same time on a single processor  machine to keep the system as busy as possible 
-> **processor can switch  between jobs**

⊙ Job spooled on disk or drum
▫	Simultaneous Peripheral Operations Online (SPOOL)
▫	Can hide slow (costly) I/O machines (ex. printer spool)
▫	Overlap of computation with asynchronous I/O
⊙ Buffering and **interrupt handling** added to OS
⊙ **Memory protection & relocation**
⊙ **Concurrent** programming become necessary
⊙ Job schedulers select jobs to run according to a variety of criteria, including priority, memory size, etc.

![](https://velog.velcdn.com/images/eunwoo1341/post/fdf557a0-7087-4b61-a5a8-3be337c0bb8e/image.png)

## 주요 차이점

- 처리 방식:
Batch Processing: 작업들이 순차적으로 처리됨.
Multiprogramming: 여러 프로그램이 동시에 메모리에 로드되어, CPU가 프로그램들 사이를 빠르게 전환하며 처리.


- CPU 활용도:
Batch Processing: I/O 작업 중에는 CPU가 유휴 상태로 대기하게 되므로 CPU 활용도가 낮음.
Multiprogramming: 한 작업이 I/O를 기다릴 때 다른 작업을 처리하므로 CPU 활용도가 높음.

- 자원 관리:
Batch Processing: 한 번에 하나의 작업만 자원을 독점적으로 사용.
Multiprogramming: 여러 작업이 자원을 공유하며 동시에 실행.

- 요약
Batch Processing은 작업을 순차적으로 처리하는 방식이며, 주로 대규모 일괄 처리가 필요할 때 사용됩니다.
Multiprogramming은 여러 프로그램을 동시에 실행하여 자원을 최대한 효율적으로 사용하는 방식으로, 현대 운영 체제의 기본적인 기능입니다.

***
# Operating System 필요성

## Memory relocation

![](https://velog.velcdn.com/images/eunwoo1341/post/6fb5ede5-48e9-4f88-833c-205af259fbbf/image.png)

다 사용한 job은 빼고 다음 job을 Memory에 넣으면  Memory relocation이 발생함 (주소가 dynamic함) 
Operating system 에서 모든 job들에 대해서 계속 tracking해야함

**-> Memory relocation**



## Memory Protection

![](https://velog.velcdn.com/images/eunwoo1341/post/01428025-fb15-4242-8d3d-52264d277751/image.png)

MultiProgramming Batch system을 하기 때문에 개별 job들이 
Memory에 올라와 있으니 Memory Protection이 필요함


## Base/bound registers

![](https://velog.velcdn.com/images/eunwoo1341/post/9f366b41-76f9-41a0-962c-71b06d03dc67/image.png)

- Base 레지스터:
프로세스가 사용할 수 있는 메모리 영역의 시작 주소를 저장하는 레지스터입니다. 각 프로세스는 메모리 상의 특정 영역을 할당받는데, 그 시작 주소가 Base 레지스터에 저장됩니다.
프로세스가 메모리에 접근할 때, 이 Base 레지스터를 기준으로 상대적인 주소를 계산하여 물리적 메모리 주소를 생성합니다.
- Bound 레지스터:
프로세스가 사용할 수 있는 메모리 영역의 최대 크기를 저장하는 레지스터입니다. Base 레지스터에서 시작한 메모리 범위 내에서, Bound 레지스터에 설정된 크기만큼의 범위에서만 접근이 허용됩니다.
프로세스가 메모리에 접근할 때, 이 Bound 레지스터를 사용해 접근하려는 주소가 할당된 메모리 범위를 벗어나는지 확인합니다.

***

## Concurrency & Synchronization

![](https://velog.velcdn.com/images/eunwoo1341/post/29ddd6ba-08fd-49aa-83b4-62d3dec6160a/image.png)

< Parallel 와 Concurrency 차이 >
Parallel: 실질적으로 병렬 코어에서 동시에 일어나는 것 (물리적으로)
Concurrency :싱글코어에서 동시에 일어나는 것처럼 보이는 것

***

## Time-sharing processing (1970s ~ 1980s)

- Hardware cheap, humans expensive -> Make efficient use of people's time

- A logical extension of **Batch-multiprogramming** systems - the CPU switches  jobs so frequently that multiple users can interact with each job while it is  running, creating interactive computing
▫	Each user has at least one program executing in memory -> process
▫	Response time < 1 sec.

- System clock generates interrupt
▫	At each clock, the system regained control and assigned the processor to another job  -> time slicing
▫	Job & process scheduling (Round-robin)

- If processes don't fit in memory, swapping moves them in and out to run
▫	Virtual memory and disk management

## Batch Multiprogramming 과 Time sharing 차이점

<table>
  <thead>
    <tr>
      <th></th>
      <th>Batch Multiprogramming</th>
      <th>Time sharing</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Objective</td>
      <td>Maximize CPU utilization</td>
      <td>Minimize response time</td>
    </tr>
    <tr>
      <td>Source of directives to OS</td>
      <td>Job control language commands provided with the job</td>
      <td>Commands entered at the terminal</td>
    </tr>
  </tbody>
</table>



export default function Layout({children}) {
  return <div className="prose">{children}</div>;
}
