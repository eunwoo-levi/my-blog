---
title: '자바스크립트의 이벤트 루프와 비동기 통신의 이해'
author: 'Eunwoo'
thumbnail: '/thumbnail/javascript.webp'
publishDate: '2025-03-21'
categoryId: 2
---

Javascript는 싱글 스레드에서 작동한다. 즉 기본적으로 Javascript는 한 번에 하나의 작업만 동기 방식으로만 처리할 수 있다.

동기(synchronous) 방식은 작업을 순차적으로 처리하는 방식이다. 이는 코드가 작성된 순서대로 실행되며, 이전 작업이 완료되어야 다음 작업을 수행할 수 있다.
다른 말로 하면, 이 요청이 시작된 이후에는 무조건 응답을 받은 이후에야 비로소 다른 작업을 처리할 수 있다.
그동안 다른 모든 작업은 대기한다. 이러한 방식은 개발자에게 매우 직관적으로 다가오지만 한 번에 다양한 많은 작업을 처리할 수 없다.

반대의 의미인 비동기(Asynchronous) 방식은 직렬 방식이 아닌 병렬 방식으로 작업을 처리하는 것을 의미한다.
요청을 시작한 후 이 응답이 오건 말건 상관없이 다음 작업이 이루어지며, 따라서 한 번에 여러 작업이 실행될 수 있다.

Javascript는 분명히 싱글 스레드에서 동기 방식으로 작동하지만 이러한 싱글 스레드 기반의 자바스크립트에서도 많은 양의 비동기 작업이 이루어지고 있다.
모던 웹 어플리케이션에서는 사용자에게 많은 양의 정보를 다양한 방식으로 제공하기 위해서 많은 것이 비동기로 작동한다.
구체적인 예시를 들어보면, 사용자가 검색어를 입력해 검색을 위한 네트워크 요청이 발생하는 순간에도 사용자는 다른 작업을 처리할 수 있다.

분명 Javascript는 싱글 스레드의 동기식으로 작동하므로 검색의 결과를 받기 전까지 아무런 작업도 하지 못하는 것이 자연스러워 보인다.
하지만 우리는 웹페이지에서 다양한 비동기 작업을 수행하고 있다.

이 처럼 리액트에도 비동기식으로 작동하는 작업이 존재한다.
자바스크립트 환경에서 이러한 것이 어떻게 가능한지 알기 위해서는 이러한 비동기 작업이 어떻게 처리되는지 이해하고 비동기 처리를 도와주는 이벤트 루프를 비롯한 다양한 개념을 알고 있어야 한다.
비동기 코드의 작업 방식에 대해 이해한다면 자바스크립트에서 어떻게 여러 가지 요청을 동시에 처리하고 있는지, 이러한 요청받은 태스크에 대한 우선순위는 무엇인지, 또 주의할 점은 무엇인지 파악해 사용자에게 더욱 매끄러운 웹 어플리케이션 서비스를 제공할 수 있다.

# 싱글 스레드 자바스크립트

자바스크립트는 싱글 스레드 언어이다.
과거에는 프로그램을 실행하는 단위가 오직 프로세스뿐이었다.
프로세스(process)란 프로그램을 구동해 프로그램의 상태가 메모리상에서 실해되는 작업 단위를 의미한다.

즉 하나의 프로그램 실행은 하나의 프로세스를 가지고 그 프로세스 내부에서 모든 작업이 처리되는 것을 의미했다.
하지만 하나의 프로그램에서 동시에 여러 개의 복잡한 작업을 수행할 필요성이 대두됐는데, 하나의 프로그램에는 하나의 프로세스만이 할당되므로 이러한 작업을 수행하기가 어려웠다.
그래서 탄생한 더 작은 실행 단위가 바로 스레드(thread)이다.

하나의 프로세스에서는 여러 개의 스레드를 만들 수 있고, 스레드끼리는 메모리를 공유할 수 있어 여러 가지 작업을 동시에 수행할 수 있다.
이에 따라 프로세스 내부에는 여러 개의 스레드를 활용하면서 동시 다발적인 작업을 처리할 수 있게 된 것이다.

그렇다면 Javascript는 왜 싱글 스레드로 설계됐을까?
멀티 스레드는 앞서 언급한 여러 가지 이점이 있지만 내부적으로 처리가 복잡하다는 단점이 있다.
스레드는 하나의 프로세스에서 동시에 서로 다른 자원에 접근할 수 있는데, 동시에 여러 작업을 수행하다 보면 같은 자원에 대해 여러 번 수정하는 등 동시성 문제가 발생할 수 있어 이에 대한 처리가 필요하다.
또한 각각 격리돼 있는 프로세스와는 다르게, 하나의 스레드가 문제가 생기면 같은 자원을 공유하는 다른 스레드에도 동시에 문제가 일어날 수 있다.

만약 자바스크립트가 멀티 스레딩을 지원해서 동시에 여러 스레드가 DOM을 조작할 수 있다면 어떻게 될까?
앞서 이야기한 것 처럼 멀티 스레딩은 메모리 공유로 인해 동시에 같은 자원에 접근하면 타이밍 이슈가 발생할 수 있고, 이는 브라우저 DOM 표시에 큰 문제를 야기할 수 있다.

자바스크립트가 싱글 스레드라는 것은 무엇을 의미할까?
자바스크립트 코드의 실행이 하나의 스레드에서 순차적으로 이루어진다는 것을 의미한다.
하나의 스레드에서 순차적으로 이루어진다는 것은 코드를 한 줄 한 줄 실행한다는 것을 의미하며 궁극적으로 하나의 작업이 끝나기 전까지는 뒤이은 작업이 실행되지 않는다는 것을 의미한다.
C 언어나 다른 메이저 프로그래밍 언어에서는 스레드에서 실행 중인 함수를 시스템이 임의로 멈추고 다른 스레드의 코드를 먼저 실행할 수 있지만 자바스크립트에서는 그런 기능이 존재하지 않는다.

자바스크립트에서는 하나의 코드가 실행하는 데 오래 걸리면 뒤이은 코드가 실행되지 않는다는 특징이 있다.
이러한 자바스크립트의 특징을 "Run-to-completion" 이라고 한다.
이러한 특징은 자바스크립트 개발자에게 동시성을 고민할 필요가 없다는 아주 큰 장점이 되지만, 반대로 때에 따라서 웹페이지에서는 단점이 될 수 있다.
하나의 작업이 끝나기 전까지는 다른 작업이 실행되지 않으므로 어떠한 작업이 오래 걸린다면 사용자에게 마치 웹페이지가 멈춘 것 같은 느낌을 줄 수 있다.
결론적으로 Run-to-completion, 즉 자바스크립트의 모든 코드는 '동기식'으로 한 번에 하나씩 순차적으로 처리된다.

그렇다면 비동기는 무엇일까?
자바스크립트에서 비동기 함수를 선언할 때 쓰는 async는 영어로 'asynchronous', 즉 동시에 일어나지 않는 것을 의미한다.

동기(synchronous)식과 같이 요청한 즉시 결과가 주어지지 않을 수도 있고, 따라서 응답이 언제 올지도 알 수 없다. 그러나 동기식과 다르게 여러 작업을 동시에 수행할 수 있다는 장점이 있다.

```js
console.log(l);

setTimeout(() => {
  console.log(2);
}, 0);

setTimeout(() => {
  console.log(3);
}, 100);

console.log(4);
```

해당 콘솔 출력의 순서가 1, 4, 2, 3으로 나타난다는 것은 쉽게 알 수 있다.
그런데 사실 자바스크립트의 특징, 즉 싱글 스레드로 작동하기 때문에 모든 코드는 "Run-to-completion" 으로 작동해야 하므로 결론적으로 1, 2, 3(0.1초 후), 4 순서로 출력되어야 정상이다.
그러나 그렇지 않다. 동기식으로 작동하는 자바스크립트 세상에서 어떻게 이런 비동기 코드를 처리할 수 있는 것일까?
이러한 사실을 이해하려면 "이벤트 루프" 라는 개념을 이해해야 한다.

# 이벤트 루프란?

설명할 내용은 자바스크립트 런타임 중에서 가장 유명한 V8을 기준으로 작성됐다. 다른 자바스크립트 런타임에서는 작동에 약간의 차이가 있을 수 있다.

이벤트 루프란 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치라 볼 수 있다.
V8, Spider Monkey 같은 현대의 자바스크립트 런타임 엔진에는 자바스크립트 코드가 효과적으로 실행하기 위한 여러가지 장치들이 마련돼 있다.

# 호출 스택과 이벤트 루프

호출 스택(call stack)은 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아주는 스택이다.

다음 간단한 코드를 살펴보자.

```js
function bar() {
  console.log('bar');
}

function baz() {
  console.log('baz');
}

function foo() {
  console.log('too');
  bar();
  baz();
}

foo();
```

이 코드는 foo를 호출하고, 내부에서 bar, baz를 순차적으로 호출하는 구조로 돼 있다. 이 코드들은 대략 다음과 같은 순서로 호출 스택에 쌓이고 비워지게 된다.

- 1. foo()가 호출스택에 먼저 들어간다.
- 2. foo() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
- 3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo()는 존재)
- 4. bar()가 호출 스택에 들어간다.
- 5. bar() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
- 6. 5의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo(), bar()는 존재)
- 7. 더 이상 bar()에 남은 것이 없으므로 호출 스택에서 제거된다. (아직 foo()는 존재)
- 8. baz()가 호출 스택에 들어간다.
- 9. baz() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
- 10. 9의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo(), baz()는 존재)
- 11 더 이상 baz()에 남은 것이 없으므로 호출 스택에서 제거된다. (아직 foo()는 존재)
- 12 더 이상 foo()에 남은 것이 없으므로 호출 스택에서 제거된다.
- 13 이제 호출 스택이 완전히 비워졌다.

이 호출 스택이 비어 있는지 여부를 확인하는 것이 바로 이벤트 루프다.
이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야 할 작업이 있는지 확인하고, 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다.
한 가지 알아둘 점은 '코드를 실행하는 것'과 '호출 스택이 비어있는지 확인하는 것' 모두가 단일 스레드에서 일어난다는 점이다.
즉, 두 작업은 동시에 일어날 수 없으며 한 스레드에서 순차적으로 일어난다.

그렇다면 비동기 작업은 어떻게 실행될까?

```js
function bar() {
  console.log('bar');
}

function baz() {
  console.log('baz');
}

function foo() {
  console.log('foo');
  setTimeout(bar(), 0); // setTimeout만 추가했다.
  baz();
}

foo();
```

우리는 앞선 예제와 다르게 foo, baz, bar 순으로 출력되는 것을 알고 있을 것이다. 실제로 호출 스택 내부에서는 다음과 같은 일이 발생한다

- 1. foo()가 호출 스택에 먼저 들어간다.
- 2. foo() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
- 3. 2의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo()는 존재)
- 4. setTimeout(bar(), 0)이 호출 스택에 들어간다.
- 5. 4번에 대해 타이머 이벤트가 실행되며 태스크 큐로 들어가고, 그 대신 바로 스택에서 제거된다.
- 6. baz()가 호출 스택에 들어간다.
- 7. baz() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
- 8. 7의 실행이 완료된 이후에 다음 코드로 넘어간다. (아직 foo(), baz()는 존재)
- 9. 더 이상 baz()에 남은 것이 없으므로 호출 스택에서 제거된다. (아직 foo()는 존재)
- 10. 더 이상 foo()에 남은 것이 없으므로 호출 스택에서 제거된다.
- 11. 이제 호출 스택이 완전히 비워졌다.
- 12. 이벤트 루프가 호출 스택이 비워져 있다는 것을 확인했다. 그리고 태스크 큐를 확인하니 4번에 들어갔던 내용이 있어 bar()를 호출 스택에 들여보낸다.
- 13. bar() 내부에 console.log가 존재하므로 호출 스택에 들어간다.
- 14. 13의 실행이 끝나고, 다음 코드로 넘어간다. (아직 bar() 존재)
- 15. 더 이상 bar()에 남은 것이 없으므로 호출 스택에서 제거된다.

위 코드를 보면, `setTimeout(() => {}), 0`이 정확하게 0초 뒤에 실행된다는 것을 보장하지 못한다는 것을 이해하게 될 것이다.

여기서부터는 태스트 큐라는 새로운 개념이 등장한다. 태스트 큐란 실행해야 할 태스크의 집합을 의미한다.
이벤트 루프는 이러한 태스트 큐를 한 개 이상 가지고 있다. 그리고 이름과 달리 태스트 큐는 자료 구조의 큐(queue)가 아닌 set 형태를 띄고 있다.
그 이유는 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하기 때문이다.
자료구조인 큐는 무조건 앞에 있는 것을 FIFO(First In First Out) 형식으로 꺼내와야 하지만 태스크 큐는 그렇지 않다.
태스크 큐에서 의미하는 ‘실행해야 할 태스크’라는 것은 비동기 함수의 콜백 함수나 이벤트 핸들러 등을 의미한다.

즉, 이벤트 루프의 역할은 호출 스택에 실행 중인 코드가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할을 한다.
호출 스택이 비었다면 태스크 큐에 대기 중인 작업이 있는지 확인하고, 이 작업을 실행 가능한 오래된 것부터 순차적으로 꺼내와서 실행하게 된다.
이 작업 또한 마찬가지로 태스크큐가 빌 때까지 이루어진다.

그렇다면 이 비동기 함수는 누가 수행하는 것일까?
n초 뒤에 setTimeout을 요청하는 작업은 누가 처리할까? fetch를 기반으로 실행되는 네트워크 요청은 누가 보내고 응답을 받을 것인가?
이러한 작업들은 모두 자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행된다.
이 별도의 스레드에서 태스크 큐에 작업을 할당해 처리하는 것은 브라우저나 Node.js의 역할이다.
즉, 자바스크립트 코드 실행은 싱글 스레드에서 이루어지지만 이러한 외부 Web API 등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어가는 것이다.
이벤트 루프는 호출 스택이 비고, 콜백이 실행 가능한 때가 오면 이것을 꺼내서 수행하는 역할을 하는 것이다.
만약 이러한 작업들도 모두 자바스크립트 코드가 실행되는 메인 스레드에서만 이루어진다면 절대로 비동기 작업을 수행할 수 없을 것이다.

# 태스크 큐와 마이크로태스크 큐

태스크 큐와 다르게, 마이크로 태스크 큐라는 것도 있다. 이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있는데, 기존의 태스크 큐와는 다른 태스크를 처리한다.
여기에 들어가는 마이크로 태스크에는 대표적으로 Promise가 있다.
이 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다. 즉, setTimeout과 setinterval은 Promise보다 늦게 실행된다.
명세에 따르면, 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미루어진다.

각 태스크에 들어가는 대표적인 작업은 다음과 같다.

- 태스크 큐: setTimeout, setinterval, setlmmediate
- 마이크로 태스크 큐: process.nextTick, Promises, queueMicroTask, MutationObserver

그렇다면 렌더링은 언제 실행될까?

태스크 큐를 실행하기에 앞서 먼저 마이크로 태스크 큐를 실행하고, 이 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다.
각 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다.

```js
<html>
  <body>
    <ul>
      <li>동기 코드: <button id="sync">0</button></li>
      <li>태스크: <button id="macrotask">0</button></li>
      <li>마이크로 태스크: <button id="microtask">0</button></li>
    </ul>
    <button id="macro_micro">모두 동시 실행</button>
  </body>

  <script>
    const button = document.getElementById('run');
    const sync = document.getElementById('sync');
    const macrotask = document.getElementById('macrotask');
    const microtask = document.getElementById('microtask');
    const macro_micro = document.getElementById('macro_micro');

    // 동기 코드로 버튼에 1부터 렌더링
    sync.addEventListener('click', function () {
      for (let i = 0; i <= 100000; i++) {
        sync.innerHTML = i;
      }
    });

    // setTimeout으로 태스크 큐에 작업을 넣어서 1부터 렌더링
    macrotask.addEventListener('click', function () {
      for (let i = 0; i <= 100000; i++) {
        setTimeout(() => {
          macrotask.innerHTML = i;
        }, 0);
      }
    });

    // queueMicrotask로 마이크로 태스크 큐에 넣어서 1부터 렌더링
    microtask.addEventListener('click', function () {
      for (let i = 0; i <= 100000; i++) {
        queueMicrotask(() => {
          microtask.innerHTML = i;
        });
      }
    });

    macro_micro.addEventListener('click', function () {
      for (let i = 0; i <= 100000; i++) {
        sync.innerHTML = i;
        setTimeout(() => {
          macrotask.innerHTML = i;
        }, 0);
        queueMicrotask(() => {
          microtask.innerHTML = i;
        });
      }
    });
  </script>
</html>

```

위 예제 코드의 결과를 정리하면 다음과 같다.

- 동기 코드는 우리가 예상했던 것처럼 해당 연산, 즉 100,000까지 숫자가 올라가기 전까지는 렌더링이 일어나지 않다가 for 문이 끝나야 비로소 렌더링 기회를 얻으며 100.000이라는 숫자가 한 번에 나타난다.
- 태스크 큐(setTimeout)는 모든 setTimeout 콜백이 큐에 들어가기 전까지 잠깐의 대기 시간을 갖다가 1부터 100.000까지 순차적으로 렌더링되는 것을 볼 수 있다.
- 마이크로 태스크 큐(queueMicrotask)는 동기 코드와 마찬가지로 렌더링이 전혀 일어나지 않다가 100,000까지 다 끝난 이후에야 한 번에 렌더링이 일어난다.
- 모든 것을 동시에 실행했을 경우 동기 코드와 마이크로 태스크 큐만 한 번에 100,000까지 올라가고, 태스크 큐만 앞선 예제처럼 순차적으로 렌더링되는 것을 볼 수 있다

---

## 예제

### 예제 1

![](https://velog.velcdn.com/images/eunwoo1341/post/264e9d46-a7c6-47a3-ac4b-65cdd3dbebc2/image.png)

#### 답안

- logBanana가 호출되어 console.log가 실행된다.
- logBanana가 콜스택에 들어온다.
- logBanana의 console.log가 콜스택에 들어온다.
- console.log가 콜스택으로부터 빠져나가고 이후 logBanana가 빠져나간다.
- logApple가 호출되어 콜스택에 쌓인다.
- logApple 내부에 있는 콜백 함수가 호출되면서 웹 API에 setTiemout 요청을 보낸다.
- logApple가 콜 스택에서 빠져나간다
- logOrange가 호출되어 콜 스택에 들어간다.
- logOrange의 console.log가 콜스택에 들어온다.
- console.log가 콜스택으로부터 빠져나가고 이후 logOrange가 빠져나간다.
- 웹 api의 타이머가 만료되고 사과의 콜백 함수(console.log)가 태스크 큐에 들어간다.
- 태스트큐에 있는 콜백을 콜스택으로 이동시켜 실행시킨다.
- 콜백 실행 완료 후 콜스택에서 빠져나간다.

### 예제 2. 왜 1->3->2->4 순으로 출력되는지 설명하시오.

```js
console.log('1');
setTimeout(() => console.log('2'));
new Promise((resolve) => resolve()).then(() => {
  console.log('3');
});
setTimeout(() => console.log('4'));
```

#### 답안

- console.log("1")는 즉시 실행됩니다. 동기 방식이므로 바로 출력됩니다.
- setTimeout(() => console.log("2"))는 비동기 함수입니다. 기본적으로 0초 지연을 주기 때문에 콜백 큐에 들어가게 되고, 이벤트 루프가 실행되는 시점에서 출력됩니다. setTimeout은 웹 API에 의해 처리되고, 그 이후에 태스트 큐에 등록됩니다.
- new Promise((resolve) => resolve()).then(() => { console.log("3") })에서 then은 마이크로태스크 큐에 등록됩니다. 마이크로태스크 큐는 이벤트 루프에서 우선순위가 더 높기 때문에 setTimeout보다 먼저 실행됩니다. 따라서 "3"이 먼저 출력됩니다.
- 두 번째 setTimeout(() => console.log("4"))는 첫 번째 setTimeout과 마찬가지로 비동기 함수이며, 마지막에 태스트 큐에서 실행되므로 "4"가 마지막에 출력됩니다.

### 예제 3. 왜 두 개의 for문의 결과가 다른지 설명하시오.

```js
for (var i = 0; i < 10; i++) {
  setTimeout(() => console.log(i)); // 10이 10번 출력
}
```

```js
for (var i = 0; i < 10; i++) {
  (function (i) {
    setTimeout(() => console.log(i)); // 0 1 2 3 4 5 6 7 8 9
  })(i);
}
```

#### 답안

```js
for (var i = 0; i < 10; i++) {
  setTimeout(() => console.log(i)); // 10이 10번 출력
}
```

- var의 함수 스코프:
  var로 선언된 i는 함수 스코프를 가지므로, for문 내부의 모든 setTimeout 콜백이 같은 i 변수를 참조합니다.
- 비동기 실행 시점:
  for문이 종료된 후, i의 최종값은 10입니다.
  setTimeout의 콜백은 비동기적으로 실행되므로, 실행 시점에 모두 동일한 값 10을 출력하게 됩니다.

```js
for (var i = 0; i < 10; i++) {
  (function (i) {
    setTimeout(() => console.log(i)); // 0 1 2 3 4 5 6 7 8 9
  })(i);
}
```

- 즉시 실행 함수(IIFE)의 사용:
  IIFE 내부에 전달된 매개변수 i는 함수의 인자로 받으므로, 각 반복마다 그 시점의 i 값이 새로운 함수 스코프에 캡처됩니다.

- 독립적 클로저 생성:
  이 방식으로 각 setTimeout 콜백은 자신만의 독립적인 i 값을 가지게 되어, for문 실행 당시의 값(0부터 9까지)을 각각 출력하게 됩니다.

##### 결론

- 첫 번째 for문: 동일한 함수 스코프 내의 i를 공유하기 때문에 모든 콜백은 최종값인 10을 출력합니다.
- 두 번째 for문: IIFE를 사용하여 각 반복마다 새로운 스코프를 생성, 그 스코프에 현재의 i 값을 캡처하므로 원하는 값(0~9)을 순서대로 출력할 수 있습니다.

### 예제 4. foo 함수에서 getPopularMovies를 호출한 결괏값을 받아서 console에 출력하시오.

단, foo 함수는 async 키워드를 붙일 수 없다.

```js
async function getPopularMovies() {
  await new Promise((resolve) => setTimeout(resolve, 1000));
  return ['쿵푸팬더4', '댐즐', '스리 아시', '돼지와 뱀과 비둘기', '듄: 파트 2', '가여운 것들'];
}

function foo() {
  //✨✨✨✨✨✨✨✨✨✨✨✨✨✨ 수정 가능 영역
  //✨✨✨✨✨✨✨✨✨✨✨✨✨✨
}
foo();
```

#### 답안

- `getPopularMovies`는 비동기 함수로, 1초의 지연 후 영화 목록을 반환합니다. 이 함수는 Promise를 반환하기 때문에, foo 함수 내에서 이를 호출할 때는 result는 Promise 객체가 됩니다.

만약 문제 조건에 `단, foo 함수는 async 키워드를 붙일 수 없다.` 라는 조건이 없을 때 아래와 같이 답을 작성할 수 있습니다.

- 답안 1

```js
const movies = await getPopularMovies();
console.log(movies);
```

하지만 현재는 이러한 조건이 있기 때문에, foo 함수에는 async 키워드를 붙일 수 없으므로, await를 사용할 수 없습니다.
그래서 `.then()`을 사용하여 Promise의 결괏값을 처리할 수 있습니다.

- 답안 2

```js
getPopularMovies().then((movies) => console.log(movies));
```

- Promise의 처리:
  getPopularMovies()가 반환하는 Promise는 내부적으로 1초 후에 영화 목록 배열을 resolve합니다.

- .then() 사용:
  .then() 메서드를 사용하면 Promise가 해결된 후 인자로 넘겨진 콜백 함수가 실행되며, 이때 movies에는 영화 배열이 들어옵니다.

- 비동기 흐름 관리:
  이를 통해 foo 함수 내에서 비동기 작업의 결과를 안전하게 받아와 출력할 수 있습니다.

### 예제 5. `getPopularMovies` 함수가 3초 이상 지연되면 "대기 시간이 오래 걸립니다"라는 오류 메시지를 콘솔로 출력하시오.

(단, 3초 이상 지연 시 getPopularMovies는 작업이 중단되거나 결괏값은 무시된다.)

```js
console.error('대기 시간이 오래 걸립니다');
```

아래의 영역에 코드를 채워 넣고 왜 해당 코드를 넣으면 해결되는지 설명하시오.

```js
const getPopularMovies = new Promise((resolve, reject) => {
  setTimeout(resolve, Math.random() * 4000 + 1000, '외부 API 접근한 결괏값');
});

// 아래에 답안을 작성하세요
```

#### 답안

```js
const getPopularMovies = new Promise((resolve, reject) => {
  setTimeout(resolve, Math.random() * 4000 + 1000, '외부 API 접근한 결괏값');
});

const timeoutPromise = new Promise((_, reject) => {
  setTimeout(() => reject('대기 시간이 오래 걸립니다'), 3000);
});

Promise.race([getPopularMovies, timeoutPromise])
  .then((result) => console.log(result))
  .catch((error) => console.error(error));
```

- getPopularMovies:

  - Math.random()을 사용하여 1~5초 사이의 랜덤 지연 후 '외부 API 접근한 결괏값'을 resolve합니다.

- timeoutPromise:

  - 3초 후에 reject되도록 설정되어 있습니다.
  - 3초 내에 getPopularMovies가 완료되지 않으면 이 Promise가 먼저 reject되어 "대기 시간이 오래 걸립니다" 오류 메시지가 출력됩니다.

- Promise.race:
  - 배열 내의 Promise 중 가장 먼저 완료(또는 실패)하는 Promise의 결과를 반환합니다.
  - 만약 getPopularMovies가 3초 이내에 resolve된다면 .then()의 콜백이 실행되어 결과를 출력합니다.
  - 그렇지 않고 3초 후 timeoutPromise가 reject되면, .catch()의 콜백이 실행되어 오류 메시지를 출력합니다.

두 Promise를 동시에 시작하여, 둘 중 하나가 먼저 완료되는 것을 기준으로 결과를 처리하기 때문에 지연 시간이 3초 이상일 경우 오류를 빠르게 감지할 수 있습니다.

# 정리

지금까지 자바스크립트 환경에서 비동기 처리가 어떻게 이루어지는지 살펴봤다.
자바스크립트 코드를 실행하는 것 자체는 싱글 스레드로 이루어져서 비동기를 처리하기 어렵지만 자바스크립트 코드를 실행하는 것 이외에 태스크 큐, 이벤트 루프, 마이크로 태스크 큐, 브라우저/Node.js API 등이 적절한 생태계를 이루고 있기 때문에 싱글 스레드로는 불가능한 비동기 이벤트 처리가 가능해진 것이다.
